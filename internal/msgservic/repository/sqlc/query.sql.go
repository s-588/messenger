// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAttachment = `-- name: CreateAttachment :one
INSERT INTO attachments(
    message_id, file_name, file_type, file_size, file_url
) VALUES(
    $1, $2, $3, $4, $5
) RETURNING attachment_id, message_id, file_name, file_type, file_size, file_url
`

type CreateAttachmentParams struct {
	MessageID uuid.UUID
	FileName  pgtype.Text
	FileType  pgtype.Text
	FileSize  pgtype.Int4
	FileUrl   pgtype.Text
}

func (q *Queries) CreateAttachment(ctx context.Context, arg CreateAttachmentParams) (Attachment, error) {
	row := q.db.QueryRow(ctx, createAttachment,
		arg.MessageID,
		arg.FileName,
		arg.FileType,
		arg.FileSize,
		arg.FileUrl,
	)
	var i Attachment
	err := row.Scan(
		&i.AttachmentID,
		&i.MessageID,
		&i.FileName,
		&i.FileType,
		&i.FileSize,
		&i.FileUrl,
	)
	return i, err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversations(
    name
)VALUES(
    $1
)RETURNING conversation_id, name, creation_date
`

func (q *Queries) CreateConversation(ctx context.Context, name string) (Conversation, error) {
	row := q.db.QueryRow(ctx, createConversation, name)
	var i Conversation
	err := row.Scan(&i.ConversationID, &i.Name, &i.CreationDate)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages(
    conversation_id,sender_id, message_body
) VALUES (
    $1, $2, $3
) RETURNING message_id, conversation_id, sender_id, sent_at, message_body
`

type CreateMessageParams struct {
	ConversationID uuid.UUID
	SenderID       uuid.UUID
	MessageBody    pgtype.Text
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage, arg.ConversationID, arg.SenderID, arg.MessageBody)
	var i Message
	err := row.Scan(
		&i.MessageID,
		&i.ConversationID,
		&i.SenderID,
		&i.SentAt,
		&i.MessageBody,
	)
	return i, err
}

const createParticipant = `-- name: CreateParticipant :one
INSERT INTO participants(
    conversation_id, user_id
) VALUES (
    $1, $2
) RETURNING participant_id, conversation_id, user_id
`

type CreateParticipantParams struct {
	ConversationID uuid.UUID
	UserID         uuid.UUID
}

func (q *Queries) CreateParticipant(ctx context.Context, arg CreateParticipantParams) (Participant, error) {
	row := q.db.QueryRow(ctx, createParticipant, arg.ConversationID, arg.UserID)
	var i Participant
	err := row.Scan(&i.ParticipantID, &i.ConversationID, &i.UserID)
	return i, err
}

const deleteAttachmentByID = `-- name: DeleteAttachmentByID :exec
DELETE FROM attachments
WHERE attachment_id = $1
`

func (q *Queries) DeleteAttachmentByID(ctx context.Context, attachmentID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttachmentByID, attachmentID)
	return err
}

const deleteAttachmentByMessageID = `-- name: DeleteAttachmentByMessageID :exec
DELETE FROM attachments
WHERE message_id = $1
`

func (q *Queries) DeleteAttachmentByMessageID(ctx context.Context, messageID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttachmentByMessageID, messageID)
	return err
}

const deleteConversation = `-- name: DeleteConversation :exec
DELETE FROM conversations
WHERE conversation_id = $1
`

func (q *Queries) DeleteConversation(ctx context.Context, conversationID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteConversation, conversationID)
	return err
}

const deleteMessageByID = `-- name: DeleteMessageByID :exec
DELETE FROM messages
WHERE message_id = $1
`

func (q *Queries) DeleteMessageByID(ctx context.Context, messageID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessageByID, messageID)
	return err
}

const deleteMessagesBySenderID = `-- name: DeleteMessagesBySenderID :exec
DELETE FROM messages
WHERE sender_id = $1
`

func (q *Queries) DeleteMessagesBySenderID(ctx context.Context, senderID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessagesBySenderID, senderID)
	return err
}

const deleteParticipantByConversationID = `-- name: DeleteParticipantByConversationID :exec
DELETE FROM participants
WHERE conversation_id = $1
`

func (q *Queries) DeleteParticipantByConversationID(ctx context.Context, conversationID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteParticipantByConversationID, conversationID)
	return err
}

const deleteParticipantByID = `-- name: DeleteParticipantByID :exec
DELETE FROM participants
WHERE participant_id = $1
`

func (q *Queries) DeleteParticipantByID(ctx context.Context, participantID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteParticipantByID, participantID)
	return err
}

const deleteParticipantByUserID = `-- name: DeleteParticipantByUserID :exec
DELETE FROM participants
WHERE user_id = $1
`

func (q *Queries) DeleteParticipantByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteParticipantByUserID, userID)
	return err
}

const findMessagesByMessageBody = `-- name: FindMessagesByMessageBody :many
SELECT message_id, conversation_id, sender_id, message_body
FROM messages
WHERE to_tsvector(message_body) @@ to_tsquery($1)
ORDER BY sent_at DESC
LIMIT $2 OFFSET $3
`

type FindMessagesByMessageBodyParams struct {
	ToTsquery string
	Limit     int32
	Offset    int32
}

type FindMessagesByMessageBodyRow struct {
	MessageID      uuid.UUID
	ConversationID uuid.UUID
	SenderID       uuid.UUID
	MessageBody    pgtype.Text
}

func (q *Queries) FindMessagesByMessageBody(ctx context.Context, arg FindMessagesByMessageBodyParams) ([]FindMessagesByMessageBodyRow, error) {
	rows, err := q.db.Query(ctx, findMessagesByMessageBody, arg.ToTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindMessagesByMessageBodyRow
	for rows.Next() {
		var i FindMessagesByMessageBodyRow
		if err := rows.Scan(
			&i.MessageID,
			&i.ConversationID,
			&i.SenderID,
			&i.MessageBody,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMessagesByConversationID = `-- name: GetAllMessagesByConversationID :many
SELECT message_id,conversation_id, message_body 
FROM messages
WHERE conversation_id = $1
ORDER BY sent_at DESC
LIMIT $2 OFFSET $3
`

type GetAllMessagesByConversationIDParams struct {
	ConversationID uuid.UUID
	Limit          int32
	Offset         int32
}

type GetAllMessagesByConversationIDRow struct {
	MessageID      uuid.UUID
	ConversationID uuid.UUID
	MessageBody    pgtype.Text
}

func (q *Queries) GetAllMessagesByConversationID(ctx context.Context, arg GetAllMessagesByConversationIDParams) ([]GetAllMessagesByConversationIDRow, error) {
	rows, err := q.db.Query(ctx, getAllMessagesByConversationID, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMessagesByConversationIDRow
	for rows.Next() {
		var i GetAllMessagesByConversationIDRow
		if err := rows.Scan(&i.MessageID, &i.ConversationID, &i.MessageBody); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMessagesBySenderID = `-- name: GetAllMessagesBySenderID :many
SELECT message_id,conversation_id, message_body 
FROM messages
WHERE sender_id = $1
ORDER BY sent_at DESC
LIMIT $2 OFFSET $3
`

type GetAllMessagesBySenderIDParams struct {
	SenderID uuid.UUID
	Limit    int32
	Offset   int32
}

type GetAllMessagesBySenderIDRow struct {
	MessageID      uuid.UUID
	ConversationID uuid.UUID
	MessageBody    pgtype.Text
}

func (q *Queries) GetAllMessagesBySenderID(ctx context.Context, arg GetAllMessagesBySenderIDParams) ([]GetAllMessagesBySenderIDRow, error) {
	rows, err := q.db.Query(ctx, getAllMessagesBySenderID, arg.SenderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMessagesBySenderIDRow
	for rows.Next() {
		var i GetAllMessagesBySenderIDRow
		if err := rows.Scan(&i.MessageID, &i.ConversationID, &i.MessageBody); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllParticipantsByConversationID = `-- name: GetAllParticipantsByConversationID :many
SELECT participant_id, user_id
FROM participants
WHERE conversation_id = $1
`

type GetAllParticipantsByConversationIDRow struct {
	ParticipantID uuid.UUID
	UserID        uuid.UUID
}

func (q *Queries) GetAllParticipantsByConversationID(ctx context.Context, conversationID uuid.UUID) ([]GetAllParticipantsByConversationIDRow, error) {
	rows, err := q.db.Query(ctx, getAllParticipantsByConversationID, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllParticipantsByConversationIDRow
	for rows.Next() {
		var i GetAllParticipantsByConversationIDRow
		if err := rows.Scan(&i.ParticipantID, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllParticipantsByUserID = `-- name: GetAllParticipantsByUserID :many
SELECT participant_id, conversation_id 
FROM participants
WHERE user_id = $1
`

type GetAllParticipantsByUserIDRow struct {
	ParticipantID  uuid.UUID
	ConversationID uuid.UUID
}

func (q *Queries) GetAllParticipantsByUserID(ctx context.Context, userID uuid.UUID) ([]GetAllParticipantsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getAllParticipantsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllParticipantsByUserIDRow
	for rows.Next() {
		var i GetAllParticipantsByUserIDRow
		if err := rows.Scan(&i.ParticipantID, &i.ConversationID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachmentByID = `-- name: GetAttachmentByID :one
SELECT message_id, file_name, file_type, file_size, file_url
FROM attachments 
WHERE attachment_id = $1
`

type GetAttachmentByIDRow struct {
	MessageID uuid.UUID
	FileName  pgtype.Text
	FileType  pgtype.Text
	FileSize  pgtype.Int4
	FileUrl   pgtype.Text
}

func (q *Queries) GetAttachmentByID(ctx context.Context, attachmentID uuid.UUID) (GetAttachmentByIDRow, error) {
	row := q.db.QueryRow(ctx, getAttachmentByID, attachmentID)
	var i GetAttachmentByIDRow
	err := row.Scan(
		&i.MessageID,
		&i.FileName,
		&i.FileType,
		&i.FileSize,
		&i.FileUrl,
	)
	return i, err
}

const getAttachmentByMessageID = `-- name: GetAttachmentByMessageID :one
SELECT attachment_id, file_name, file_type, file_size, file_url
FROM attachments 
WHERE message_id = $1
`

type GetAttachmentByMessageIDRow struct {
	AttachmentID uuid.UUID
	FileName     pgtype.Text
	FileType     pgtype.Text
	FileSize     pgtype.Int4
	FileUrl      pgtype.Text
}

func (q *Queries) GetAttachmentByMessageID(ctx context.Context, messageID uuid.UUID) (GetAttachmentByMessageIDRow, error) {
	row := q.db.QueryRow(ctx, getAttachmentByMessageID, messageID)
	var i GetAttachmentByMessageIDRow
	err := row.Scan(
		&i.AttachmentID,
		&i.FileName,
		&i.FileType,
		&i.FileSize,
		&i.FileUrl,
	)
	return i, err
}

const getConversationsByID = `-- name: GetConversationsByID :one
SELECT name, creation_date 
FROM conversations
WHERE conversation_id = $1
`

type GetConversationsByIDRow struct {
	Name         string
	CreationDate pgtype.Timestamp
}

func (q *Queries) GetConversationsByID(ctx context.Context, conversationID uuid.UUID) (GetConversationsByIDRow, error) {
	row := q.db.QueryRow(ctx, getConversationsByID, conversationID)
	var i GetConversationsByIDRow
	err := row.Scan(&i.Name, &i.CreationDate)
	return i, err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT conversation_id, sender_id, message_body 
FROM messages
WHERE message_id = $1
`

type GetMessageByIDRow struct {
	ConversationID uuid.UUID
	SenderID       uuid.UUID
	MessageBody    pgtype.Text
}

func (q *Queries) GetMessageByID(ctx context.Context, messageID uuid.UUID) (GetMessageByIDRow, error) {
	row := q.db.QueryRow(ctx, getMessageByID, messageID)
	var i GetMessageByIDRow
	err := row.Scan(&i.ConversationID, &i.SenderID, &i.MessageBody)
	return i, err
}

const getParticipantByID = `-- name: GetParticipantByID :one
SELECT conversation_id, user_id 
FROM participants
WHERE participant_id = $1
`

type GetParticipantByIDRow struct {
	ConversationID uuid.UUID
	UserID         uuid.UUID
}

func (q *Queries) GetParticipantByID(ctx context.Context, participantID uuid.UUID) (GetParticipantByIDRow, error) {
	row := q.db.QueryRow(ctx, getParticipantByID, participantID)
	var i GetParticipantByIDRow
	err := row.Scan(&i.ConversationID, &i.UserID)
	return i, err
}

const searchConversationByName = `-- name: SearchConversationByName :many
SELECT conversation_id, name, creation_date
FROM conversations
WHERE to_tsvector(name) @@ to_tsquery($1)
`

func (q *Queries) SearchConversationByName(ctx context.Context, toTsquery string) ([]Conversation, error) {
	rows, err := q.db.Query(ctx, searchConversationByName, toTsquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conversation
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(&i.ConversationID, &i.Name, &i.CreationDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConversationName = `-- name: UpdateConversationName :exec
UPDATE conversations
    set name = $2
WHERE conversation_id = $1
`

type UpdateConversationNameParams struct {
	ConversationID uuid.UUID
	Name           string
}

func (q *Queries) UpdateConversationName(ctx context.Context, arg UpdateConversationNameParams) error {
	_, err := q.db.Exec(ctx, updateConversationName, arg.ConversationID, arg.Name)
	return err
}

const updateMessageBody = `-- name: UpdateMessageBody :exec
Update messages
    set message_body = $2
WHERE message_id = $1
`

type UpdateMessageBodyParams struct {
	MessageID   uuid.UUID
	MessageBody pgtype.Text
}

func (q *Queries) UpdateMessageBody(ctx context.Context, arg UpdateMessageBodyParams) error {
	_, err := q.db.Exec(ctx, updateMessageBody, arg.MessageID, arg.MessageBody)
	return err
}
